<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>耗子也疯狂的博客</title>
    <link>http://CrazyMouse.github.io</link>
    <description>耗子也疯狂的博客</description>
    
      <item>
        <title>编码、解码、乱码……一切从字节流说起</title>
        <link>http://CrazyMouse.github.io/2014/04/29/%E7%BC%96%E7%A0%81%E3%80%81%E8%A7%A3%E7%A0%81%E3%80%81%E4%B9%B1%E7%A0%81%E2%80%A6%E2%80%A6%E4%B8%80%E5%88%87%E4%BB%8E%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%B4%E8%B5%B7.html</link>
        <guid isPermaLink="true">http://CrazyMouse.github.io/2014/04/29/%E7%BC%96%E7%A0%81%E3%80%81%E8%A7%A3%E7%A0%81%E3%80%81%E4%B9%B1%E7%A0%81%E2%80%A6%E2%80%A6%E4%B8%80%E5%88%87%E4%BB%8E%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%B4%E8%B5%B7.html</guid>
        <pubDate>Tue, 29 Apr 2014 00:00:00 +0800</pubDate>
        <description>&lt;h2&gt;我们从最底层的说起&lt;/h2&gt;

&lt;h3&gt;二进制的世界&lt;/h3&gt;

&lt;p&gt;计算机从设计出来的那一天起，就注定了它只能理解0和1两种状态，一切我们看到的文字、图象、声音等都是从这最简单的0和1基础上抽象出来的。一堆的01在一起，在没有建立规则的情况下，是没有任何意义的，就像我们熟悉的用来制造CPU的硅一样，硅是什么？满世界都是，沙子的主要成分就是硅了。满世界的沙子就像那一堆的01010101一样，在没有经过人制定的规则进行联合起来的时候，是没有任何价值的。于是，人们开始制定规则，这一个个的0和1被叫做bit(比特)，8个bit构成一个byte，也就是说01010101这就表示一个byte了。为什么要引出byte的概念？因为1个byte就可以表示-128到127之间的数字了，于是它的把这本身没有意义的8个bit建立出一个规则，使它变得有意义了。因为bit和物层的高低电位有关，太底层，我们后面的内容就以byte为下限来说明。  &lt;/p&gt;

&lt;h3&gt;由byte构建起来的计算机体系&lt;/h3&gt;

&lt;p&gt;如果说bit是泥巴，那byte就是砖了，有了砖就能建造出各式各样的建筑。两个byte放一起，就成了char，4个byte放一起，就变成了int，8个byte放一起，就变成了double，N个byte放一起，就成了string，N个string放一起就变成一篇文章了，文章的联合马伊俐就……扯远了。 于是，计算机王国就建立起来了。它的基石就是那个叫byte的板砖，而再下面，就是那没有意义的泥巴bit了。  &lt;/p&gt;

&lt;h3&gt;来，我们聊个天&lt;/h3&gt;

&lt;p&gt;人与人之间交流靠什么?语言。那语言的载体是什么？声音。而声音则是通过空气传播。那计算机之间交流靠什么？靠计算机语言啊。那计算机语言的载体是什么？计算机网络。网络则是建立是电流的基础上，因此对应该关系是这个样子嘀：&lt;br&gt;
&lt;strong&gt;人类语言----计算机语言&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;声音----计算机网络&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;空气----电流&lt;/strong&gt;  &lt;/p&gt;

&lt;p&gt;我们从声音说起，声音就是一系列的机械波，计算机上就是我们前面说的泥巴了。我们平时只要哼哼唧唧就能发出声音来，同样计算机可以以哼唧一下发出一堆毫无意义的字节流，这哼唧出来的至于是什么意思，别的计算机当然也就不懂了。为了让这些发出的声音有意义，那就得制定规则，于是，更上层的语言就产生了。&lt;br&gt;
大家都知道，计算机是老美发明的，那么，他们的母语是英语，这就有个天然的优势了。我们上面讲到过，一个byte可以用来表示-128-127的范围，而英文中一共才26个字母，用一个byte来表示一个英文字母是足够的了，因为它即使算上大小写也才52个。人可以制定出规则，指定每个字母和一个数字相对应，这样，计算机之间就可以通过英文来聊天了。老大哥的问题是解决了，可是其它非英语体系的国家人民也要用电脑啊，就拿天朝来说，那么多的汉字，肯定用一个byte是表示不全的，一个byte撑死表示256个字。因此更复杂的规则就建议起来了。不是说一位不够嘛，那我们可以用多个byte来表示啊。从此，百花齐放的时代来临，各种编码格式比如GBK、GB2312
UTF-8、UTF-16……全部出来了。通俗点讲，所谓的编码格式，无非就是规则而已，用来表示当前的到底用几个byte来表示一个字符，并且注意一下，很多编码集并不是每个字符都是定长的，原因在于为了节省空间。那问题来了，为什么只有非英文的会产生乱码而英文的不会呢?我们前面说到过，一个byte就可以完整的表示一个英文字母了，因此，各种其它的英文编码集，都以一个byte来表示英文，所以无论怎么变，它都不会乱码了。  &lt;/p&gt;

&lt;h3&gt;一次完整的计算机交谈&lt;/h3&gt;

&lt;h4&gt;网络规则协议&lt;/h4&gt;

&lt;p&gt;要了计算机怎么聊天，我们不得不得一个叫做七层网络协议的东西，如下图所示：&lt;br&gt;
&lt;img src=&quot;/public/upload/7%E5%B1%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE.png&quot; alt=&quot;Mou icon&quot;&gt;&lt;br&gt;
上图我们注意到以下几点：  &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;物理层传送的都是010101的字节流，也叫bit流&lt;br&gt;&lt;/li&gt;
&lt;li&gt;我们平时进行的操作基本上都是在位置1的应用层，换句话讲，我们所谓的socket开发，已经是站在七层协议的顶端了&lt;/li&gt;
&lt;li&gt;我们熟悉的TCP协议位置传输层，因为和网络层结合紧密，所以一般我们说TCP/IP协议&lt;/li&gt;
&lt;li&gt;A计算机的应用要和B计算机的应用通信，需要经过上图所示的一个流程才能到达&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有了上面的知识做铺垫，我们可以来详细的描述一次计算机之间的通信了  &lt;/p&gt;

&lt;h4&gt;自顶向下的编码&lt;/h4&gt;

&lt;p&gt;注：这里的数据我没经过计算，只是讲原理&lt;/p&gt;

&lt;p&gt;需求：A机器上的应用要和B机器上的应该打招呼，它想对B说『你好』，就这么简单的一个词，我们来看看从A想做这个事开始，到把数据转换成bit流的这个过程中，都发生了哪些事情。&lt;br&gt;
我们假定GBK编码一个中文占2个字节，UTF8占3个，那么，这两种不同的编码会形成如下差异：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/upload/%E7%BC%96%E7%A0%81.png&quot; alt=&quot;Mou icon&quot;&gt;   &lt;/p&gt;

&lt;p&gt;我们可以看到同样的两个字，经过不同的编码，生成的byte数组不一样，bit流也就不一样了，因此，网络通信必须要知道对方使用的编码集。要知道B机器对bit流还原成『你好』二字，完全是一个逆过程，如果不知道编码集，是没办法还原的。总结起来说，所谓的乱码，&lt;strong&gt;就是在不知道编码规则的情况下，按照特殊的解码方式进行了解码&lt;/strong&gt;，当然，不排除瞎猫撞上死老鼠，你就给碰对了。  &lt;/p&gt;

&lt;h3&gt;写在最后，看不看随便&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;有人会问，你这说的是网络通信，那我的文件乱码呢?我的控制台乱码呢？&lt;/strong&gt;&lt;br&gt;
对于前一个问题，看看上面的图，把物理层的网络换成磁盘，就明白了。所谓的控制台，终端乱码，就一个原因，系统输出的编码和你的终端或者控制台设置的不一致，没有别的原因。(比如说我们远程连接到一个linux服务器，用SCRT做为客户端，服务端linux的系统编码集是UTF-8的，而SCRT默认的设置显示编码集是GBK的，那乱码问题就出现了，怎么解决不用说了吧)&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件乱码的特殊性&lt;/strong&gt;&lt;br&gt;
文件与网络bit流有个不同的地方，文件会在开头的一段字节中描述文件的编码格式，很多时候会有人问，为什么把文件的编码格式变了，还是乱码的问题，用上面的图来讲解就是，我们用GBK编码『你好』，并把它写到文件中，同时文件中的编码格式也是写的GBK，这时候读出来是没错的。然后错就错在，有一天，我们要把这个文件变成UTF8编码的，然后我们在操作过程中，只是把文件里面那个描述符改了，而文件本身没进行重新编码，因此再读的时候按UTF8读，当然出问题了。更通俗的讲，一个箱子里放了只猫，然后外面的标签写的里面是猫，我们打开箱子把这个动物拿出来当猫使肯定是没问题的，但如果哪条我们要把箱子放条狗，结果我们操作的流程只把标签换了，而猫没取出来放进去狗，那么，下次我们把盒子打开拿出来的动物当狗，必出问题无疑。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一个大端小端的问题&lt;/strong&gt;&lt;br&gt;
网络数据传输中会遇到一个大端序和小端序的概念，什么意思呢？看上面的图，『你好』的『你』字编码后是24和38，我怎么知道先发24还是先发38呢？这就是大端小端问题的通俗解释。网络协议规定我们都用大端序，so问题解决了，但为什么我们还要关心这个问题呢?因为总是有应用很有个性要用小端序嘛，所以我们在socket通信的时候要注意一下。注：java的socket默认都用大端序，但有方法可以转小端。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;java应用内部用什么编码？&lt;/strong&gt;&lt;br&gt;
有人会问了，java不是跨平台么，那么，在各个平台上，它内部用什么格式来存字符串的？答案是UTF16。也就是说，不管数据来的是什么格式，在java应用中的string都是UTF16编码的，因此，我们可以由此推出几个问题：&lt;br&gt;

&lt;ol&gt;
&lt;li&gt;如果数据从文件读取，debug的时候发现有字符串乱码，那么可以肯定是读文件时候的使用的编码格式和&lt;strong&gt;实际存储的格式&lt;/strong&gt;不一致。
2.如果从网络来的数据，那么，肯定是和发送方用的编码格式不一致。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总结起来，解决乱码一句话：&lt;strong&gt;用什么编码的，就用什么解码&lt;/strong&gt; 貌似是废话╮(╯_╰)╭&lt;/p&gt;
</description>
      </item>
    
  </channel>
</rss>